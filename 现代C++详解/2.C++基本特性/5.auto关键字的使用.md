## auto关键字的使用
auto是C++11新加入的关键字，就是为了简化一些写法。
代码演示：

使用auto推断类型确实简单方便，但有个基本要求，就是在使用auto时清楚的知道编译器会给auto推断出什么类型。
为了学习auto的类型推断，我使用一个boost库来确定变量的具体类型。至于boost是什么，这里就不介绍了，大家可以去百度一下。
boost库的类型推断更加灵活方便，直观。而且Part10讲万能引用，完美转发时boost也是必须使用的，所以这里就提前使用boost了。其实这里采用vs默认提供的类型提示功能也可以。

首先下载，安装boost库，就直接视频演示了，不在文档中描述了。

这两个命令执行完毕，boost库也就编译好了。boost库很大，可以选择编译自己想要的模块，我就直接全部编译了。boost是很复杂的，不是几句话能说清楚，要深入理解可以去官网学习。
两个库，每一个编译都需要十几分钟，所以视频就暂停了。

这两个命令我放在一个boostCommand.txt的文件中，这个文件已经放在最终的文件包中。

auto有几个点需要注意：
有些不好理解，可以多看几遍，或者带着问题学习下面的课程，Part2的所有知识都是反复用到的。

1. auto只能推断出类型，引用不是类型，所以auto无法推断出引用，要使用引用只能自己加引用符号。

代码演示：

2. auto关键字在推断引用的类型时：会直接将引用替换为引用指向的对象。其实引用一直是这样的，引用不是对象，任何使用引用的地方都可以直接替换成引用指向的对象。

代码演示：

3. auto关键字在推断类型时，如果没有引用符号，会忽略值类型的const修饰，而保留修饰指向对象的const，典型的就是指针。可能有些不好理解，看看代码就好说了。3和4的主要作用对象就是指针。

代码演示：

4. auto关键字在推断类型时，如果有了引用符号，那么值类型的const和修饰指向对象的const都会保留。

代码演示：

其实3，4为什么会出现这种情况，因为在传递值时，修改这个值并不会对原有的值造成影响。而传递引用时，修改这个值会直接对原有的值造成影响。

确实不太好理解，尤其是基础不扎实的人。不懂了可以多问问我。

5. 当然，我们可以在前面加上const，这样永远都有const的含义。

代码演示：

6. auto不会影响编译速度，甚至会加快编译速度。因为编译器在处理XX a = b时，当XX是传统类型时，编译期需要检查b的类型是否可以转化为XX。当XX为auto时，编译期可以按照b的类型直接给定变量a的类型，所以效率相差不大，甚至反而还有提升。
7. （*）最重要的一点，就是auto不要滥用，对于一些自己不明确的地方不要乱用auto，否则很可能出现事与愿违的结果，使用类型应该安全为先。
8. （*）auto主要用在与模板相关的代码中，一些简单的变量使用模板常常导致可读性下降，经验不足还会导致安全性问题。

注意：auto的用法这里大致了解就可以了，Part10会有一节详细的讲auto的类型推断的，这节课是没有涉及右值引用的，那里会将这一部分。而且现在没有讲模板，难以讲出auto关键字的主要用法。
